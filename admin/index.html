const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');
const os = require('os');
const https = require('https');
const http = require('http');

class LicenseManager {
    constructor() {
        this.secretKey = 'photosync-2024-secret-key-v1';
        this.licenseFile = path.join(os.homedir(), '.photosync-license');
        this.serverUrl = 'https://droners1.github.io/photosync-server/photosync-status.json';
        this.serverCheckInterval = 24 * 60 * 60 * 1000; // 24 hours
        this.serverTimeout = 10000; // 10 seconds
        this.blacklistFile = path.join(os.homedir(), '.photosync-blacklist');
    }

    // Generate a license key (for distribution)
    generateLicenseKey(userInfo = '') {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2, 8).toUpperCase();
        const baseKey = `PSYNC-2024-${random}-${timestamp.toString(36).toUpperCase()}`;
        
        // Create HMAC signature (not including userInfo for universal keys)
        const hmac = crypto.createHmac('sha256', this.secretKey);
        hmac.update(baseKey);
        const signature = hmac.digest('hex').substring(0, 8).toUpperCase();
        
        return `${baseKey}-${signature}`;
    }

    // Validate a license key
    validateLicenseKey(licenseKey, userInfo = '') {
        try {
            const parts = licenseKey.split('-');
            if (parts.length !== 5 || parts[0] !== 'PSYNC' || parts[1] !== '2024') {
                return false;
            }

            const baseKey = parts.slice(0, 4).join('-');
            const providedSignature = parts[4];

            // Verify HMAC signature (not including userInfo for universal keys)
            const hmac = crypto.createHmac('sha256', this.secretKey);
            hmac.update(baseKey);
            const expectedSignature = hmac.digest('hex').substring(0, 8).toUpperCase();

            return providedSignature === expectedSignature;
        } catch (error) {
            return false;
        }
    }

    // Fetch server status with timeout
    async fetchServerStatus() {
        return new Promise((resolve) => {
            const protocol = this.serverUrl.startsWith('https:') ? https : http;
            
            const request = protocol.get(this.serverUrl, {
                timeout: this.serverTimeout,
                headers: {
                    'User-Agent': 'Photosync/1.0',
                    'Cache-Control': 'no-cache'
                }
            }, (response) => {
                let data = '';
                
                response.on('data', (chunk) => {
                    data += chunk;
                });
                
                response.on('end', () => {
                    try {
                        if (response.statusCode === 200) {
                            const serverData = JSON.parse(data);
                            resolve({ success: true, data: serverData });
                        } else {
                            resolve({ success: false, error: `Server returned status ${response.statusCode}` });
                        }
                    } catch (error) {
                        resolve({ success: false, error: 'Invalid server response' });
                    }
                });
            });
            
            request.on('error', (error) => {
                resolve({ success: false, error: error.message });
            });
            
            request.on('timeout', () => {
                request.destroy();
                resolve({ success: false, error: 'Server request timeout' });
            });
            
            request.setTimeout(this.serverTimeout);
        });
    }

    // Check server blacklist and kill switch
    async checkServerStatus(licenseKey) {
        try {
            const result = await this.fetchServerStatus();
            
            if (!result.success) {
                console.log('Server check failed:', result.error);
                return { serverReachable: false, allowed: true }; // Fail open for offline usage
            }
            
            const serverData = result.data;
            
            // Check kill switch
            if (!serverData.allowAccess || serverData.maintenanceMode) {
                return { 
                    serverReachable: true, 
                    allowed: false, 
                    reason: serverData.message || 'Access temporarily disabled' 
                };
            }
            
            // Check if key is revoked
            if (serverData.revokedKeys && serverData.revokedKeys.includes(licenseKey)) {
                return { 
                    serverReachable: true, 
                    allowed: false, 
                    reason: 'License key has been revoked' 
                };
            }
            
            // Update local blacklist cache
            await this.updateLocalBlacklist(serverData.revokedKeys || []);
            
            return { serverReachable: true, allowed: true, serverData };
            
        } catch (error) {
            console.log('Server check error:', error.message);
            return { serverReachable: false, allowed: true }; // Fail open
        }
    }

    // Update local blacklist cache
    async updateLocalBlacklist(revokedKeys) {
        try {
            const blacklistData = {
                keys: revokedKeys,
                lastUpdated: new Date().toISOString()
            };
            await fs.writeFile(this.blacklistFile, JSON.stringify(blacklistData));
        } catch (error) {
            console.log('Failed to update local blacklist:', error.message);
        }
    }

    // Check local blacklist cache
    async checkLocalBlacklist(licenseKey) {
        try {
            const data = await fs.readFile(this.blacklistFile, 'utf8');
            const blacklist = JSON.parse(data);
            return blacklist.keys.includes(licenseKey);
        } catch (error) {
            return false; // No blacklist file or error reading it
        }
    }

    // Check if user has a valid license
    async checkLicense() {
        try {
            const licenseData = await fs.readFile(this.licenseFile, 'utf8');
            const parsed = JSON.parse(licenseData);
            
            // Decrypt the license data
            const algorithm = 'aes-256-cbc';
            const key = crypto.scryptSync(this.secretKey, 'salt', 32);
            const textParts = parsed.encrypted.split(':');
            const iv = Buffer.from(textParts.shift(), 'hex');
            const encryptedData = textParts.join(':');
            const decipher = crypto.createDecipheriv(algorithm, key, iv);
            let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
            decrypted += decipher.final('utf8');
            
            const license = JSON.parse(decrypted);
            
            // Validate the stored key
            if (!this.validateLicenseKey(license.key, license.userInfo || '')) {
                return { valid: false, reason: 'Invalid license key' };
            }
            
            // Check local blacklist first
            if (await this.checkLocalBlacklist(license.key)) {
                return { valid: false, reason: 'License key has been revoked' };
            }
            
            // Check if we need to contact server (every 24 hours)
            const now = Date.now();
            const lastCheck = license.lastServerCheck || 0;
            const shouldCheckServer = (now - lastCheck) > this.serverCheckInterval;
            
            if (shouldCheckServer) {
                console.log('Checking server for license status...');
                const serverStatus = await this.checkServerStatus(license.key);
                
                if (serverStatus.serverReachable) {
                    if (!serverStatus.allowed) {
                        return { valid: false, reason: serverStatus.reason };
                    }
                    
                    // Update last server check time
                    license.lastServerCheck = now;
                    license.lastServerData = serverStatus.serverData;
                    
                    // Re-encrypt and save updated license
                    const algorithm = 'aes-256-cbc';
                    const key = crypto.scryptSync(this.secretKey, 'salt', 32);
                    const iv = crypto.randomBytes(16);
                    const cipher = crypto.createCipheriv(algorithm, key, iv);
                    let encrypted = cipher.update(JSON.stringify(license), 'utf8', 'hex');
                    encrypted += cipher.final('hex');
                    encrypted = iv.toString('hex') + ':' + encrypted;
                    
                    await fs.writeFile(this.licenseFile, JSON.stringify({
                        encrypted,
                        version: '1.0'
                    }));
                }
            }
            
            return {
                valid: true,
                key: license.key,
                userInfo: license.userInfo,
                activatedAt: license.activatedAt,
                lastServerCheck: license.lastServerCheck,
                serverReachable: license.lastServerData ? true : false
            };
            
        } catch (error) {
            return { valid: false, reason: 'No license found' };
        }
    }

    // Activate a license
    async activateLicense(licenseKey, userInfo = '') {
        try {
            // Clean up the license key
            const cleanKey = licenseKey.replace(/\s+/g, '').toUpperCase();
            
            // Validate the key format first
            if (!this.validateLicenseKey(cleanKey, userInfo)) {
                return { success: false, error: 'Invalid license key format' };
            }

            // Check server status before activation
            console.log('Checking server status during activation...');
            const serverStatus = await this.checkServerStatus(cleanKey);
            
            if (serverStatus.serverReachable && !serverStatus.allowed) {
                return { success: false, error: serverStatus.reason };
            }

            // Create license data
            const licenseData = {
                key: cleanKey,
                userInfo,
                activatedAt: new Date().toISOString(),
                lastServerCheck: serverStatus.serverReachable ? Date.now() : 0,
                lastServerData: serverStatus.serverData || null
            };

            // Encrypt the license data
            const algorithm = 'aes-256-cbc';
            const key = crypto.scryptSync(this.secretKey, 'salt', 32);
            const iv = crypto.randomBytes(16);
            const cipher = crypto.createCipheriv(algorithm, key, iv);
            let encrypted = cipher.update(JSON.stringify(licenseData), 'utf8', 'hex');
            encrypted += cipher.final('hex');
            encrypted = iv.toString('hex') + ':' + encrypted;

            // Save to file
            await fs.writeFile(this.licenseFile, JSON.stringify({
                encrypted,
                version: '1.0'
            }));

            return { 
                success: true, 
                message: 'License activated successfully',
                userInfo,
                serverReachable: serverStatus.serverReachable
            };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    // Check if license key format is valid (basic check)
    isValidFormat(licenseKey) {
        const pattern = /^PSYNC-2024-[A-Z0-9]{6}-[A-Z0-9]+-[A-Z0-9]{8}$/;
        return pattern.test(licenseKey.replace(/\s+/g, '').toUpperCase());
    }

    // Format license key for display
    formatLicenseKey(key) {
        const clean = key.replace(/\s+/g, '').toUpperCase();
        const parts = clean.split('-');
        if (parts.length === 5) {
            return `${parts[0]}-${parts[1]}-${parts[2]}-${parts[3]}-${parts[4]}`;
        }
        return clean;
    }

    // Get license info for display
    async getLicenseInfo() {
        const license = await this.checkLicense();
        if (license.valid) {
            const serverStatus = license.lastServerCheck ? 
                (Date.now() - license.lastServerCheck < this.serverCheckInterval ? 'Recently verified' : 'Verification pending') :
                'Not verified';
                
            return {
                key: license.key,
                userInfo: license.userInfo || 'Not specified',
                activatedAt: new Date(license.activatedAt).toLocaleDateString(),
                status: 'Active',
                serverStatus,
                lastServerCheck: license.lastServerCheck ? new Date(license.lastServerCheck).toLocaleDateString() : 'Never'
            };
        }
        return null;
    }

    // Remove license (for testing or deactivation)
    async removeLicense() {
        try {
            await fs.unlink(this.licenseFile);
            // Also remove blacklist cache
            try {
                await fs.unlink(this.blacklistFile);
            } catch (e) {
                // Ignore if blacklist file doesn't exist
            }
            return true;
        } catch (error) {
            return false;
        }
    }

    // Legacy method compatibility for existing code
    async checkLicenseStatus() {
        const result = await this.checkLicense();
        if (result.valid) {
            return {
                licensed: true,
                licenseData: {
                    key: result.key,
                    userInfo: result.userInfo,
                    activatedAt: result.activatedAt
                },
                keyInfo: {
                    type: 'standard',
                    year: '2024'
                }
            };
        } else {
            return {
                licensed: false,
                reason: result.reason
            };
        }
    }

    // Legacy method compatibility for existing code
    async saveLicenseActivation(licenseKey, userInfo = {}) {
        const result = await this.activateLicense(licenseKey, userInfo.name || '');
        return result.success;
    }
}

module.exports = LicenseManager; 
